# Challenges 41-50: "What does it mean to be beautiful?"


41.	Ask the user for a number. Determine if it is plaindromic or not. If not, reverse it and add this to the original. Check for palidrome again. Repeat until you get a palindrome. Display the number you're working on for each iteration of the loop.


42.	Find a needle in a haystack. Write a subroutine that receives two strings - one if the needle and the other is the haystack. Determine where the needle first occurs in the haystack. Return the position of the first letter of the needle in the haystack. If the needle doesn't exist, return -1.
 
 
43.	Write a subroutine that receives a string. Remove any pairs or repeating characters. `ABBA > AA > 'empty'`. Do this repeatedly until the string is either empty or contains no repeating pairs of characters. Display the string on each iteration.


44.	Write a subroutine to determine if a number is beautiful. A beautiful number has all of its digits such that we can extract a sequence of adjacent numbers. `123 > 1, 2, 3`. `91011 > 9, 10, 11`.


45.	Write a subroutine that accepts a string and a number. Make the string this length by removing characters or adding spaces from/to the left of the string.


46.	Produce another subroutine that will make a string a certain length by removing or adding characters to the right. Allow the user to specify the character to be used for padding.


47.	Produce a subroutine that will make a string a certain length by removing or adding characters to the left and the right alternatively. This will have the effect of centering the string in a string of the provided width. Allow the user to specify the character to use for padding.


48.	Ask the user for a number, find all the prime numbers up to and including the provided one.


49.	Ask the user for a number, find all the factors of this number (numbers that the original can be divided by with no remainder).
 
 
50. Ask the user for their name and their score in a test. Store this information in a dictionary with their name as the key. Keep adding new entries to the dictionary until someone provides the name STOP. Provide a mechanism for the user to look up the score of someone based on their name alone. If there is no score stored for that name, say so.
